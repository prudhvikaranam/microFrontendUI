import { Component, ElementRef, Input, ChangeDetectionStrategy, } from '@angular/core';
export class ParcelComponent {
    constructor(host) {
        this.host = host;
        this.config = null;
        this.mountParcel = null;
        this.onParcelMount = null;
        this.wrapWith = 'div';
        this.customProps = {};
        this.appendTo = null;
        this.handleError = (error) => console.error(error);
        this.hasError = false;
        this.wrapper = null;
        this.parcel = null;
        this.task = null;
    }
    ngOnChanges() {
        this.scheduleTask("update" /* Update */, () => {
            if (this.parcel !== null && this.parcel.update) {
                return this.parcel.update(this.customProps);
            }
        });
    }
    ngOnInit() {
        this.scheduleTask("mount" /* Mount */, () => {
            if (this.mountParcel === null) {
                throw new Error('single-spa-angular: the [mountParcel] binding is required when using the <parcel> component. You can either (1) import mountRootParcel from single-spa or (2) use the mountParcel prop provided to single-spa applications.');
            }
            this.wrapper = document.createElement(this.wrapWith);
            if (this.appendTo !== null) {
                this.appendTo.appendChild(this.wrapper);
            }
            else {
                this.host.nativeElement.appendChild(this.wrapper);
            }
            this.parcel = this.mountParcel(this.config, Object.assign(Object.assign({}, this.customProps), { domElement: this.wrapper }));
            if (this.onParcelMount !== null) {
                this.parcel.mountPromise.then(this.onParcelMount);
            }
            this.unmounted = false;
            return this.parcel.mountPromise;
        });
    }
    ngOnDestroy() {
        this.scheduleTask("unmount" /* Unmount */, () => {
            if (this.parcel !== null && this.parcel.getStatus() === 'MOUNTED') {
                return this.parcel.unmount();
            }
        });
        if (this.wrapper !== null) {
            this.wrapper.parentNode.removeChild(this.wrapper);
        }
        this.unmounted = true;
    }
    scheduleTask(action, task) {
        if (this.hasError && action !== "unmount" /* Unmount */) {
            // In an error state, we don't do anything anymore except for unmounting
            return;
        }
        this.task = (this.task || Promise.resolve())
            .then(() => {
            if (this.unmounted && action !== "unmount" /* Unmount */) {
                // Never do anything once the angular component unmounts
                return;
            }
            return task();
        })
            .catch((error) => {
            this.task = Promise.resolve();
            this.hasError = true;
            if (error === null || error === void 0 ? void 0 : error.message) {
                error.message = `During '${action}', parcel threw an error: ${error.message}`;
            }
            if (typeof this.handleError === 'function') {
                this.handleError(error);
            }
            else {
                setTimeout(() => {
                    throw error;
                });
            }
            // No more things to do should be done -- the parcel is in an error state
            throw error;
        });
    }
}
ParcelComponent.decorators = [
    { type: Component, args: [{
                selector: 'parcel',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
/** @nocollapse */
ParcelComponent.ctorParameters = () => [
    { type: ElementRef }
];
ParcelComponent.propDecorators = {
    config: [{ type: Input }],
    mountParcel: [{ type: Input }],
    onParcelMount: [{ type: Input }],
    wrapWith: [{ type: Input }],
    customProps: [{ type: Input }],
    appendTo: [{ type: Input }],
    handleError: [{ type: Input }]
};
//# sourceMappingURL=parcel.component.js.map