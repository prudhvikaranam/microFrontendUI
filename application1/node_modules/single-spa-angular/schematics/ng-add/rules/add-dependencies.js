"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDependencies = void 0;
const tslib_1 = require("tslib");
const https = require("https");
const core_1 = require("@angular/core");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
function addDependencies() {
    const dependencies = [
        getSingleSpaDependency(),
        getSingleSpaAngularDependency(),
        getAngularBuildersCustomWebpackDependency(),
    ];
    return (tree, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var e_1, _a;
        try {
            for (var dependencies_2 = tslib_1.__asyncValues(dependencies), dependencies_2_1; dependencies_2_1 = yield dependencies_2.next(), !dependencies_2_1.done;) {
                const dependency = dependencies_2_1.value;
                dependencies_1.addPackageJsonDependency(tree, dependency);
                context.logger.info(`Added '${dependency.name}' as a dependency`);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (dependencies_2_1 && !dependencies_2_1.done && (_a = dependencies_2.return)) yield _a.call(dependencies_2);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.addDependencies = addDependencies;
const { version, peerDependencies, dependencies } = require('../../../package.json');
function getSingleSpaDependency() {
    const singleSpaVersion = (peerDependencies === null || peerDependencies === void 0 ? void 0 : peerDependencies['single-spa']) || (dependencies === null || dependencies === void 0 ? void 0 : dependencies['single-spa']) || 'latest';
    return {
        name: 'single-spa',
        version: singleSpaVersion,
        overwrite: true,
        type: dependencies_1.NodeDependencyType.Default,
    };
}
function getSingleSpaAngularDependency() {
    return {
        name: 'single-spa-angular',
        version,
        overwrite: false,
        type: dependencies_1.NodeDependencyType.Default,
    };
}
function getAngularBuildersCustomWebpackDependency() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return {
            name: '@angular-builders/custom-webpack',
            overwrite: false,
            type: dependencies_1.NodeDependencyType.Dev,
            version: yield resolveCustomWebpackVersion(),
        };
    });
}
function resolveCustomWebpackVersion() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let version;
        try {
            const versions = yield getCustomWebpackVersions();
            // Let's try to get all versions that might match the current major Angular version.
            // This can be:
            // `['12.0.0-beta.0', '12.0.0', '12.0.1-beta.0']`
            const majorVersions = versions.filter(version => version.startsWith(core_1.VERSION.major));
            const majorBetaVersions = majorVersions.filter(version => version.match(/-beta/) !== null);
            const majorStableVersions = majorVersions.filter(version => version.match(/-beta/) === null);
            // Well, we'd want to use the stable version first of all, for instance, `12.0.0`, and if
            // no stable version is available, then we fall back to the beta version.
            // This can happen when the new Angular version is out and the `@angular-builders/custom-webpack`
            // hasn't released the stable compatible version yet.
            version = majorStableVersions.pop() || majorBetaVersions.pop() || 'latest';
        }
        catch (_a) {
            // We could actually initialize version with the `latest` value,
            // but let's be more imperative and fallback to the `latest` value
            // if any exception has occured previously.
            version = 'latest';
        }
        return version;
    });
}
function getCustomWebpackVersions() {
    return new Promise((resolve, reject) => {
        const request = https.get({
            protocol: 'https:',
            hostname: 'registry.npmjs.com',
            path: '/@angular-builders/custom-webpack',
        }, (response) => {
            const chunks = [];
            response
                .on('error', reject)
                .on('data', chunk => {
                chunks.push(chunk);
            })
                .on('end', () => {
                const response = JSON.parse(`${Buffer.concat(chunks)}`);
                const versions = Object.keys(response.versions);
                resolve(versions);
            });
        });
        request.on('error', reject).end();
    });
}
//# sourceMappingURL=add-dependencies.js.map